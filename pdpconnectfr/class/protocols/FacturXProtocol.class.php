<?php
/* Copyright (c) 2025       Eric Seigne                 <eric.seigne@cap-rel.fr>
 * Copyright (C) 2025       Laurent Destailleur         <eldy@users.sourceforge.net>
 * Copyright (C) 2025       Mohamed DAOUD               <mdaoud@dolicloud.com>
 *
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */



/**
 * \file    pdpconnectfr/class/protocols/FacturXProtocol.class.php
 * \ingroup pdpconnectfr
 * \brief   Factur-X Protocol integration class
 */

require_once DOL_DOCUMENT_ROOT . '/compta/bank/class/account.class.php';
require_once DOL_DOCUMENT_ROOT . '/expedition/class/expedition.class.php';
require_once DOL_DOCUMENT_ROOT . '/commande/class/commande.class.php';
include_once DOL_DOCUMENT_ROOT . '/core/class/translate.class.php';
include_once DOL_DOCUMENT_ROOT . '/product/class/product.class.php';
include_once DOL_DOCUMENT_ROOT . '/core/class/discount.class.php';

use horstoeko\zugferd\codelists\ZugferdCountryCodes;
use horstoeko\zugferd\codelists\ZugferdCurrencyCodes;
use horstoeko\zugferd\codelists\ZugferdElectronicAddressScheme;
use horstoeko\zugferd\codelists\ZugferdInvoiceType;
use horstoeko\zugferd\codelists\ZugferdReferenceCodeQualifiers;
use horstoeko\zugferd\codelists\ZugferdUnitCodes;
use horstoeko\zugferd\codelists\ZugferdVatCategoryCodes;
use horstoeko\zugferd\codelists\ZugferdVatTypeCodes;
use horstoeko\zugferd\ZugferdDocumentBuilder;
use horstoeko\zugferd\ZugferdProfiles;
use horstoeko\zugferd\ZugferdDocumentPdfBuilder;
use horstoeko\zugferd\ZugferdDocumentPdfBuilderAbstract;

require __DIR__ . "/../../vendor/autoload.php";

dol_include_once('custom/pdpconnectfr/class/protocols/AbstractProtocol.class.php');

/**
 * Class to manage Factur-X Protocol integration.
 */
class FacturXProtocol extends AbstractProtocol
{

    /**
     * Generate the XML content for a given invoice according to the Factur-X standard.
     *
     * This method converts the provided invoice data into a structured XML file
     * compliant with the Factur-X specification (hybrid PDF + XML format).
     *
     * @param object $invoice Invoice object containing all necessary data.
     * @return string XML representation of the invoice.
     */
    public function generateXML($invoice)
    {
        return $invoice;
    }

    /**
     * Generate a complete Factur-X invoice file by embedding the XML
     * into a PDF.
     *
     * This function combines the invoice data with its corresponding XML
     * to produce a final hybrid document ready for exchange or archiving.
     *
     * @param object $invoice_id    Invoice ID to be processed.
     * @param string $xml           XML data generated by generateXML().
     * @return string               -1 if ko, path if ok.
     */
    public function generateInvoice($invoice_id, $xml = '', $outputlang = 'en_US')
    {
        // Global variables declaration (typical for Dolibarr environment)
        global $conf, $user, $langs, $mysoc, $db;

        require_once DOL_DOCUMENT_ROOT."/compta/facture/class/facture.class.php";

        $invoice = new Facture($db);
	    $invoiceObject = $invoice->fetch('288');

        $this->sourceinvoice = $invoice;

        // XML generation part ==================================================================
        // Initialize variables
        $ret = $prepaidAmount = 0;
        $billing_period = [];
        $deltemp = array();
        $object = $invoice;

        // Prepare Invoice Data for XML Generation
        $facture_number = $object->ref;
        $note_pub = $object->note_public ? $object->note_public : "";

        // Convert dates to DateTime objects
        $ladate = new \DateTime(dol_print_date($object->date, 'dayrfc'));
        $ladatepaiement = new \DateTime(dol_print_date($object->date_lim_reglement, 'dayrfc'));

        // details about payment mode
        $account = new Account($db);
        if ($object->fk_account > 0) {
            $bankid = $object->fk_account;
            // For backward compatibility when object->fk_account is forced with object->fk_bank
            $account->fetch($bankid);
        } else {
            $account->fetch(getDolGlobalString('FACTURX_DEFAULT_BANK_ACCOUNT'));
        }
        $account_proprio = \trim($account->owner_name);
        if ($account_proprio == '') {
            dol_syslog('Bank account holder name is empty, please correct it, use socname instead but it could be inccorrect for XRechnung BT-85: Payment account name', \LOG_WARNING);
            $account_proprio = $mysoc->name;
        }

        // customer account linked
        $contact = $object->thirdparty;
        if (isset($object->contact)) {
            $contact = $object->contact;
        }

        // Get customer order references and delivery dates
        $customerOrderReferenceList = [];
        $deliveryDateList = [];
        $this->_determineDeliveryDatesAndCustomerOrderNumbers($customerOrderReferenceList, $deliveryDateList, $object);

        // Specific handling for Chorus (French invoicing platform) ---
        // if a chorus extrafield is present we have to check if all others are ok, and display warning in case of trouble
        $chorus = false;
        $chorusErrors = [];
        if (getDolGlobalInt('PDPCONNECTFR_USE_CHORUS')) {
            $chorus = true;
        }
        $promise_code = $object->array_options['options_d4d_promise_code'] ?? '';
        if ($promise_code == '') {
            $promise_code = $object->ref_customer ?? ''; // Determine promise_code (engagement number / client ref)
        }
        if ($promise_code == '' && !empty($customerOrderReferenceList)) {
            $promise_code = $customerOrderReferenceList[0];
        }

        // Chorus errors checks
        if ($promise_code == '') {
            $chorusErrors[] = "N° d'engagement absent";
        } elseif (\strlen($promise_code) > 50 && $promise_code == $object->ref_customer) {
            $chorusErrors[] = "Ref client trop longue pour chorus (max 50 caractères)";
        }
        if ($object->array_options['options_d4d_contract_number'] == '') {
            $chorusErrors[] = "N° de marché absent";
        } else {
            $chorus = true;
        }
        if ($object->array_options['options_d4d_service_code'] == '') {
            $chorusErrors[] = "Code service absent";
        } else {
            $chorus = true;
        }
        if (isset($object->thirdparty->idprof2) && trim($object->thirdparty->idprof2) == '') {
            $chorusErrors[] = "Numéro SIRET du client manquant";
        }

        // Display Chorus warnings/errors
        if ($chorus) {
            if (count($chorusErrors) > 0) {
                setEventMessages("Alerte conformité Chorus:", $chorusErrors, 'warnings');
                dol_syslog(\get_class($this) . '::executeHooks error chorus : ' . \json_encode($chorusErrors), \LOG_ERR);
            } else {
                dol_syslog(\get_class($this) . '::executeHooks chorus enabled, no errors detected');
            }
        } else {
            dol_syslog(\get_class($this) . '::executeHooks no chorus data'); // TODO: maybe disable by default
        }


        // Base Data Validation (FacturX mandatory fields) ---
        $baseErrors = [];

        // Seller (mysoc) checks
        if (empty($mysoc->tva_intra)) {
            $baseErrors[] = $langs->trans("FxCheckErrorVATnumber");
        }
        if (empty($mysoc->address)) {
            $baseErrors[] = $langs->trans("FxCheckErrorAddress");
        }
        if (empty($mysoc->zip)) {
            $baseErrors[] = $langs->trans("FxCheckErrorZIP");
        }
        if (empty($mysoc->town)) {
            $baseErrors[] = $langs->trans("FxCheckErrorTown");
        }
        if (empty($mysoc->country_code)) {
            $baseErrors[] = $langs->trans("FxCheckErrorCountry");
        }

        // Buyer (thirdparty) checks
        if (empty($object->thirdparty->name)) {
            $baseErrors[] = $langs->trans("FxCheckErrorCustomerName");
        }
        if ($mysoc->country_code != 'FR' && empty($object->thirdparty->idprof1)) {
            // In France only SIRET (idprof2) is used
            $baseErrors[] = $langs->trans("FxCheckErrorCustomerIDPROF1");
        }
        if (empty($object->thirdparty->idprof2)) {
            $baseErrors[] = $langs->trans("FxCheckErrorCustomerIDPROF2");
        }
        if (empty($object->thirdparty->address)) {
            $baseErrors[] = $langs->trans("FxCheckErrorCustomerAddress");
        }
        if (empty($object->thirdparty->zip)) {
            $baseErrors[] = $langs->trans("FxCheckErrorCustomerZIP");
        }
        if (empty($object->thirdparty->town)) {
            $baseErrors[] = $langs->trans("FxCheckErrorCustomerTown");
        }
        if (empty($object->thirdparty->country_code)) {
            $baseErrors[] = $langs->trans("FxCheckErrorCustomerCountry");
        }
        if ($object->thirdparty->tva_assuj) {
            // Test VAT code only if thirdparty is subject to VAT
            $this->_thirdpartyCalcTva_intra($object);
            if (empty($object->thirdparty->tva_intra)) {
                $baseErrors[] = $langs->trans("FxCheckErrorCustomerVAT");
            }
        }

        // Display base data warnings
        if (count($baseErrors) > 0) {
            dol_syslog(get_class($this) . '::executeHooks baseErrors count > 0');
            setEventMessages($langs->trans("FxCheckError"), $baseErrors, 'warnings');
            dol_syslog(get_class($this) . '::executeHooks baseErrors count > 0, error = ' . json_encode($baseErrors));
        }

        // Initialize ZugferdDocumentBuilder (FacturX XML) -----------------------------------------------
        dol_syslog(\get_class($this) . '::executeHooks create new XML document based on PROFILE_EN16931 (CIUS-FR)');
        $profile = getDolGlobalString('PDPCONNECTFR_PROFILE');
        switch ($profile) {
            case 'EN16931' :
                $used_profile = ZugferdProfiles::PROFILE_EN16931;
                $facturxpdf = ZugferdDocumentBuilder::createNew($used_profile);
            default :
                $used_profile = ZugferdProfiles::PROFILE_EN16931;
                $facturxpdf = ZugferdDocumentBuilder::createNew($used_profile);
        }
        dol_syslog(\get_class($this) . '::executeHooks create new XML document based on ' . $used_profile);
        // Initialize ZugferdDocumentBuilder (FacturX XML) -----------------------------------------------


        //  Build XML Document Header (Seller, Buyer, Dates)
        $facturxpdf
            ->setDocumentInformation(
                $facture_number,
                $this->_getTypeOfInvoice($object),
                $ladate,
                $conf->currency,
                $object->ref_customer,
                $outputlang
            )
            ->addDocumentNote($note_pub)

            // ---------------- Seller ----------------
            ->setDocumentSeller($mysoc->name, $this->idprof($mysoc))
            ->addDocumentSellerTaxRegistration("VA", $mysoc->tva_intra ?? 'FRSPECIMEN')
            ->setDocumentSellerLegalOrganisation(
                $this->idprof($mysoc),
                null,
                $mysoc->name ?? 'SPECIMEN'
            )
            ->setDocumentSellerAddress(
                $mysoc->address      ?? 'ADDRESS EMPTY',
                "",
                "",
                $mysoc->zip          ?? 'ZIP EMPTY',
                $mysoc->town         ?? 'NO TOWN',
                $mysoc->country_code ?? 'COUNTRY NOT SET'
            )

            // ---------------- Buyer ----------------
            ->setDocumentBuyer(
                $object->thirdparty->name ?? 'CUSTOMER',
                $this->_remove_spaces($this->thirdpartyidprof($object) ?? 'IDPROF2')
            )
            ->setDocumentBuyerAddress(
                $object->thirdparty->address      ?? 'ADDRESS',
                "",
                "",
                $object->thirdparty->zip          ?? 'ZIP',
                $object->thirdparty->town         ?? 'TOWN',
                $object->thirdparty->country_code ?? 'COUNTRY'
            )
            ->addDocumentBuyerTaxRegistration("VA", $object->thirdparty->tva_intra ?? '')
            ->setDocumentBuyerLegalOrganisation(
                $this->_remove_spaces($this->thirdpartyidprof($object) ?? ''),
                null,
                $contact->name ?? $contact->lastname
            )
            ->setDocumentBuyerCommunication(
                'EM',
                $this->extractBuyerMail($contact, $object->thirdparty)
            );


        // Add seller ID scheme
        $facturxpdf->addDocumentSellerGlobalId($this->idprof($mysoc), $this->IEC_6523_code($mysoc->country_code)); // TODO: maybe we can add a parameter to customize this.

        // Add buyer ID scheme
        if (!empty($this->thirdpartyidprof($object))) {
            $facturxpdf->addDocumentBuyerGlobalId($this->thirdpartyidprof($object), $this->IEC_6523_code($object->thirdparty->country_code));
        }

        // Add delivery date
        if (!empty($deliveryDateList)) {
            $facturxpdf->setDocumentSupplyChainEvent(new DateTime($deliveryDateList[0]));
        }

        // Add additional referenced documents (Order references) - Disabled for Chorus
        // Not for chorus : a été rejetée pour le(s) motif(s) suivants, identifié(s) dans le flux cycle de vie : L'element (AttachmentBinaryObject.value) est obligatoire si l'element (FichierXml.SupplyChainTradeTransaction.ApplicableHeaderTradeAgreement.AdditionalReferencedDocument) est renseigne.
        if (!$chorus) {
            foreach ($customerOrderReferenceList as $customerOrderRef) {
                if ($customerOrderRef != $promise_code) {
                    $facturxpdf->addDocumentAdditionalReferencedDocument($customerOrderRef, "130");
                }
            }
        }





























        // XML generation part ==================================================================


        $filename = dol_sanitizeFileName($invoice->ref);
		$filedir = $conf->invoice->multidir_output[$invoice->entity ?? $conf->entity].'/'.dol_sanitizeFileName($invoice->ref);
        //$object_type = 'facture';


        $orig_pdf = $filedir.'/'.$filename.'.pdf';

        // Initial PDF File Pre-check ---
        $precheck = \false;
        if (\file_exists($orig_pdf) && \is_readable($orig_pdf)) {
            $finfo = \finfo_open(\FILEINFO_MIME_TYPE);
            if (\finfo_file($finfo, $orig_pdf) == 'application/pdf') {
                $precheck = \true;
            }
        }

        // Check if the source PDF is valid, log error and exit if not.
        if ($precheck == \false) {
            dol_syslog(\get_class($this) . "::executeHooks orig pdf file does not exists, can't create facturX");
            return -1;
        }

        // Load PDPConnectFR specific translations
        $outputlangs = $langs;
        $langs->loadLangs(array("admin", "pdpconnectfr@pdpconnectfr"));

        // migrating code from dolibarr
        dol_syslog('PDPConnectFR::generateInvoice');
        \clearstatcache(\true);







































        

        // --- 9. Set Trade Contact details ---
        $contacts = $object->getIdContact('internal', 'SALESREPFOLL');
        $object->user = null;

        if (empty(getDolGlobalString('FACTURX_GLOBAL_TRADECONTACT_DISABLE', ''))) {
            if (!empty($contacts) && $object->fetch_user($contacts[0]) > 0) {
                $name = $object->user->getFullName($outputlangs);
                $office_phone = $object->user->office_phone;
                $office_fax = $object->user->office_fax;
                $email = $object->user->email;
            } else {
                // Fallback to current user if no sales representative found
                $name = $user->getFullName($outputlangs);
                $office_phone = $user->office_phone;
                $office_fax = $user->office_fax;
                $email = $user->email;
            }

            // Fallback to company details if user details are missing
            if (empty($office_phone)) {
                $office_phone = $mysoc->phone;
            }
            if (empty($office_fax)) {
                $office_fax = $mysoc->fax;
            }
            if (empty($email)) {
                $email = $mysoc->email;
            }

            $facturxpdf->setDocumentSellerContact($name, "", $office_phone, $office_fax, $email);
            $facturxpdf->setDocumentSellerCommunication("EM", $email);
        }

        // --- 10. Set Buyer Reference (Service Code for Chorus) and Contract References ---
        // trigger hook for buyer reference
        $parameters = array('invoice' => $object);
        $reshook = $hookmanager->executeHooks('calculateBuyerReference', $parameters);

        // Note that $action and $object may have been
        if ($reshook < 0) {
            setEventMessages($hookmanager->error, $hookmanager->errors, 'errors');
        } elseif ($reshook > 0 && !empty($hookmanager->resPrint)) {
            $facturxpdf->setDocumentBuyerReference($hookmanager->resPrint);
        } else {
            if (!empty($object->array_options['options_d4d_service_code'])) {
                // CHORUS Debtor. Service Code
                $facturxpdf->setDocumentBuyerReference($object->array_options['options_d4d_service_code']);
            }
        }

        if (!empty($object->array_options['options_d4d_contract_number'])) {
            // CHORUS Commitment. Contract Number
            $facturxpdf->setDocumentContractReferencedDocument($object->array_options['options_d4d_contract_number']);
        }
        if (!empty($promise_code)) {
            // CHORUS Commitment. Commitment Number / Client Ref
            $facturxpdf->setDocumentBuyerOrderReferencedDocument($promise_code);
        }

        // moved after lines to get prepaid amount data
        // $facturxpdf->setDocumentSummation($object->total_ttc, $object->total_ttc, $object->total_ht, 0.0, 0.0, $object->total_ht, $object->total_tva, null, $prepaidAmount)
        //  ->addDocumentPaymentTerm($langs->transnoentitiesnoconv("PaymentConditions").": ".$langs->transnoentitiesnoconv("PaymentCondition".$object->cond_reglement_code), $ladatepaiement)
        //  ->addDocumentPaymentMean($this->get_paymentMean_number($object), $langs->transnoentitiesnoconv("PaymentType".$object->mode_reglement_code), null, null, null, null, $this->_remove_spaces($account->iban), $account_proprio, $this->_remove_spaces($account->number), $this->_remove_spaces($account->bic));

        // Set Business Process (A1/A2 for Chorus)
        if (empty(getDolGlobalString('FACTURX_DISABLE_CHORUS_EXTRAFIELDS', ''))) {
            dol_syslog("FacturX::Chorus add DocumentBusinessProcess data");
            if ($object->paye) {
                $facturxpdf->setDocumentBusinessProcess("A2");
            } else {
                $facturxpdf->setDocumentBusinessProcess("A1");
            }
        } else {
            dol_syslog("FacturX::Chorus disabled, then DocumentBusinessProcess disabled too");
        }

        // --- 11. Process Invoice Lines ---
        // is there multi VAT informatins ? in case we need to collect all data to be able to join it at the end
        $tabTVA = [];
        // in case of prepaid invoice we have to forget dolibarr point of view with negative line
        $grand_total_ht = $grand_total_tva = $grand_total_ttc = 0;

        // Determine customer language for line labels
        // use customer language
        $outputlangs = $langs;
        $newlang = '';
        if (isset($object->thirdparty->default_lang)) {
            $newlang = $object->thirdparty->default_lang;
            // for proposal, order, invoice, ...
        }
        // @phan-suppress-next-line PhanUndeclaredProperty
        if (isset($object->default_lang)) {
            $newlang = $object->default_lang;
            // for thirdparty @phan-suppress-current-line PhanUndeclaredProperty
        }
        if (GETPOST('lang_id', 'alphanohtml') != "") {
            $newlang = GETPOST('lang_id', 'alphanohtml');
        }
        if (!empty($newlang)) {
            $outputlangs = new \Translate("", $conf);
            $outputlangs->setDefaultLang($newlang);
        }

        // add invoice lines
        $numligne = 1;
        foreach ($object->lines as $line) {
            // Skip subtotal lines
            $isSubTotalLine = $this->_isLineFromExternalModule($line, $object->element, 'modSubtotal');
            if ($isSubTotalLine) {
                continue;
            }

            // Handle deposit/prepayment lines (treated as a global allowance/charge)
            if ($line->desc == '(DEPOSIT)') {
                $origFactRef = "";
                $origFactDate = new \DateTime();
                $discount = new \DiscountAbsolute($this->db);
                $resdiscount = $discount->fetch($line->fk_remise_except);
                print "<p>Fetch discount " . $line->fk_remise_except . ", res={$resdiscount}</p>";
                if ($resdiscount > 0) {
                    $origFact = new \Facture($this->db);
                    $resOrigFact = $origFact->fetch($discount->fk_facture_source);
                    print "<p>Fetch origFact " . $discount->fk_facture_source . ", res={$resOrigFact}</p>";
                    if ($resOrigFact > 0) {
                        $origFactRef = $origFact->ref;
                        $origFactDate = new \DateTime(dol_print_date($origFact->date, 'dayrfc'));
                    }
                }
                $prepaidAmount += \abs($line->total_ttc);
                $facturxpdf->addDocumentAllowanceCharge(\abs($line->total_ttc), \false, "S", "VAT", $line->tva_tx, null, null, null, null, null, "Prepayment invoice (386)", $origFactRef);
                print "<p>Set setDocumentBuyerOrderReferencedDocument : " . \json_encode($origFactRef) . " :: " . \json_encode($origFactDate) . "</p>";
                $facturxpdf->setDocumentInvoiceReferencedDocument($origFactRef, $origFactDate);
                continue;
            }

            // Get product labels (multilangs support)
            $libelle = $description = "";
            if ($newlang != "") {
                if (!isset($line->multilangs)) {
                    $tmpproduct = new \Product($db);
                    $resproduct = $tmpproduct->fetch($line->fk_product);
                    if ($resproduct > 0) {
                        $getm = $tmpproduct->getMultiLangs();
                        if ($getm < 0) {
                            dol_syslog("facturx error fetching multilang for product error is " . $tmpproduct->error, \LOG_DEBUG);
                        }
                        $line->multilangs = $tmpproduct->multilangs;
                    } else {
                        dol_syslog("facturx error fetching product", \LOG_DEBUG);
                    }
                }
                if (isset($line->multilangs)) {
                    $libelle = $line->multilangs[$newlang]["label"];
                    $description = $line->multilangs[$newlang]["description"];
                }
            }
            if (empty($libelle)) {
                $libelle = $line->product_label ? $line->libelle : "libre";
            }
            if (empty($description)) {
                $description = $line->desc ? $line->desc : "";
            }
            $lineref = $line->ref ? $line->ref : "0000";
            $lineproductref = $line->product_ref ? $line->product_ref : "0000";

            // Add the line item to the XML
            $facturxpdf->addNewPosition($numligne)->setDocumentPositionProductDetails($libelle, $description, $lineproductref)->setDocumentPositionGrossPrice($line->subprice)->setDocumentPositionNetPrice($line->subprice)->setDocumentPositionQuantity($line->qty, "H87")->setDocumentPositionLineSummation($line->total_ht);

            // Set billing period for the line
            if (!empty($line->date_start)) {
                $billing_period["start"][$numligne] = $line->date_start;
            }
            if (!empty($line->date_end)) {
                $billing_period["end"][$numligne] = $line->date_end;
            }
            if (isset($billing_period["start"][$numligne]) && isset($billing_period["end"][$numligne])) {
                $facturxpdf->setDocumentPositionBillingPeriod($this->_tsToDateTime($billing_period["start"][$numligne]), $this->_tsToDateTime($billing_period["end"][$numligne]));
            }

            // Handle negative amount lines as a line discount
            // please read 3 types of discount available
            // https://github.com/horstoeko/zugferd/wiki/Creating-XML-Documents#working-with-discounts-and-charges
            if ($line->subprice < 0) {
                dol_syslog("facturx : there is negative line, convert as a global discount", \LOG_INFO);
                // setEventMessages($langs->transnoentitiesnoconv('FxNegativeLine'), [], 'warnings');
                // print json_encode($line);exit;
                $facturxpdf->addDocumentPositionGrossPriceAllowanceCharge(\abs($line->subprice) * $line->qty, \false, null, null, "Discount");
                //other ideas
                // $facturxpdf->addDocumentPositionAllowanceCharge(abs($remise_amount), true, null, null, null, "Discount");
                // $facturxpdf->addDocumentAllowanceCharge(abs($line->subprice) * $line->qty, false, "S","VAT", $line->tva_tx,null, null, null, null, null, null, "Discount");
            }

            // VAT informations (Line Tax)
            if ($line->tva_tx > 0) {
                $facturxpdf->addDocumentPositionTax('S', 'VAT', $line->tva_tx);
            } else {
                $facturxpdf->addDocumentPositionTax('K', 'VAT', '0.00');
            }

            // Discount percentage on a line
            if (isset($line->remise_percent) && $line->remise_percent > 0) {
                $remise_amount = $line->total_ht - $line->subprice * $line->qty;
                dol_syslog("facturx : there is a discount on that line : " . $line->remise_percent . ", amount is " . $remise_amount);
                $facturxpdf->addDocumentPositionAllowanceCharge(\abs($remise_amount), \false, $line->remise_percent, $line->subprice * $line->qty, null, "Discount");
            }

            // Aggregate VAT totals for document summary
            if (!isset($tabTVA[$line->tva_tx])) {
                $tabTVA[$line->tva_tx] = [];
            }
            if (!isset($tabTVA[$line->tva_tx]['totalHT'])) {
                $tabTVA[$line->tva_tx]['totalHT'] = 0;
            }
            if (!isset($tabTVA[$line->tva_tx]['totalTVA'])) {
                $tabTVA[$line->tva_tx]['totalTVA'] = 0;
            }
            $tabTVA[$line->tva_tx]['totalHT'] += $line->total_ht;
            $tabTVA[$line->tva_tx]['totalTVA'] += $line->total_tva;

            // Update grand totals
            $grand_total_ht += $line->total_ht;
            $grand_total_ttc += $line->total_ttc;
            $grand_total_tva += $line->total_tva;

            $numligne++;
        }

        // --- 12. Final Document Summation and Payment Means ---

        // Multi VAT (Document Tax Summary)
        foreach ($tabTVA as $k => $v) {
            $code = "S";
            if ($k == 0) {
                $code = 'K';
            }
            $facturxpdf->addDocumentTax($code, "VAT", $v['totalHT'], $v['totalTVA'], $k);
        }

        // Set final summation details (totals, payable amount, prepaid amount)
        $facturxpdf->setDocumentSummation($grand_total_ttc, $grand_total_ttc - $prepaidAmount, $grand_total_ht, 0.0, 0.0, $grand_total_ht, $grand_total_tva, null, $prepaidAmount)->addDocumentPaymentTerm($langs->transnoentitiesnoconv("PaymentConditions") . ": " . $langs->transnoentitiesnoconv("PaymentCondition" . $object->cond_reglement_code), $ladatepaiement)->addDocumentPaymentMean($this->_get_paymentMean_number($object), $langs->transnoentitiesnoconv("PaymentType" . $object->mode_reglement_code), null, null, null, null, $this->_remove_spaces($account->iban), $account_proprio, $this->_remove_spaces($account->number), $this->_remove_spaces($account->bic));

        // is there a billing period for that invoice ?
        //setDocumentBillingPeriod

        // --- 13. Finalization, Validation, and Saving ---

        // Create XML file for debug if enabled
        if (getDolGlobalString('FACTURX_XML_STANDALONE')) {
            $xmlfile = \str_replace('.pdf', '_facturx.xml', $orig_pdf);
            $facturxpdf->writeFile($xmlfile);
        }

        // Validate the generated XML document
        dol_syslog(\get_class($this) . '::executeHooks try to validate XML');
        $pdfCheck = new ZugferdDocumentValidator($facturxpdf);
        $res = $pdfCheck->validateDocument();
        if (\count($res) > 0) {
            $allErrors = $this->_getAllMessages($res);
            // if (empty(getDolGlobalString('FACTURX_USE_TRIGGER',''))) {
            setEventMessages($allErrors, [], 'errors');
            // }
            // $this->errors[] = json_encode($res);
            dol_syslog(\get_class($this) . '::executeHooks  (1) : ' . $allErrors, \LOG_ERR);
        }

        // Embed XML into PDF and save
        $pdfBuilder = new ZugferdDocumentPdfBuilder($facturxpdf, $orig_pdf);
        $pdfBuilder->generateDocument();

        $new_pdf = $orig_pdf;
        if (getDolGlobalString('FACTURX_SUFFIX_ENABLE', '') != '') {
            $suffix = getDolGlobalString('FACTURX_SUFFIX_CUSTOM', '_facturx');
            $new_pdf = \str_replace('.pdf', $suffix . '.pdf', $orig_pdf);
        }

        $pdfBuilder->saveDocument($new_pdf);
        dol_syslog(\get_class($this) . '::executeHooks save facturx document to : ' . $new_pdf . ', checksum : ' . \sha1_file($new_pdf));

        // Rename if no suffix is used
        if (empty(getDolGlobalString('FACTURX_SUFFIX_ENABLE', '')) && \file_exists($new_pdf)) {
            \rename($new_pdf, $orig_pdf);
        }

        \clearstatcache(\true);

        // dol_syslog(get_class($this) . '::executeHooks end action=' . $action . ', file saved as ' . $new_pdf);
        return $ret;
    }

    /**
     * Generate a sample Factur-X invoice for demonstration or testing purposes.
     *
     * This method creates a dummy invoice with representative data
     * to illustrate the Factur-X structure without using real business information.
     *
     * @return string Path or content of the generated sample invoice.
     */
    public function generateSampleInvoice()
    {
        require __DIR__ . "/ExampleHelpers.php";

        $existingPdfFilename = __DIR__ . "/../../assets/00_ZugferdDocumentPdfBuilder_PrintLayout.pdf";
        $newPdfFilename = __DIR__ . "/../../tmp/02_ZugferdDocumentPdfBuilder_PrintLayout_Merged.pdf";
        $AdditionalDocument = __DIR__ . "/../../assets/00_AdditionalDocument.csv";

        // First we create a new valid document in EN16931-Profile (== COMFORT-Profile)
        // See examples/01_ZugferdDocumentBuilder_EN16931.php for detailed explanations

        $documentBuilder = ZugferdDocumentBuilder::createNew(ZugferdProfiles::PROFILE_EN16931);

        $documentBuilder->setDocumentInformation(
            'R-2024/00001',                                     // Invoice Number (BT-1)
            ZugferdInvoiceType::INVOICE,                        // Type "Invoice" (BT-3)
            DateTime::createFromFormat("Ymd", "20241231"),      // Invoice Date (BT-2)
            ZugferdCurrencyCodes::EURO                          // Invoice currency is EUR (Euro) (BT-5)
        );

        $documentBuilder->addDocumentNote('Lieferant GmbH' . PHP_EOL . 'Lieferantenstraße 20' . PHP_EOL . '80333 München' . PHP_EOL . 'Deutschland' . PHP_EOL . 'Geschäftsführer: Hans Muster' . PHP_EOL . 'Handelsregisternummer: H A 123' . PHP_EOL . PHP_EOL, null, 'REG');
        $documentBuilder->setDocumentBillingPeriod(DateTime::createFromFormat("Ymd", "20250101"), DateTime::createFromFormat("Ymd", "20250131"), "01.01.2025 - 31.01.2025");
        $documentBuilder->addDocumentInvoiceSupportingDocumentWithUri('REFDOC-2024/00001-1', 'http.//some.url', 'Inhaltsstoffe Joghurt');
        $documentBuilder->addDocumentInvoiceSupportingDocumentWithFile('REFDOC-2024/00001-2', $AdditionalDocument, 'Herkunftsnachweis Trennblätter');
        $documentBuilder->addDocumentTenderOrLotReferenceDocument('LOS 738625');
        $documentBuilder->addDocumentInvoicedObjectReferenceDocument('125', ZugferdReferenceCodeQualifiers::SALE_PERS_NUMB); // Sales person number
        $documentBuilder->setDocumentContractReferencedDocument('CON-2024/2025-001');
        $documentBuilder->setDocumentProcuringProject('PROJ-2025-001-1', 'Allgemeine Dienstleistungen');
        $documentBuilder->addDocumentPaymentMeanToDirectDebit("DE12500105170648489890", "R-2024/00001");
        $documentBuilder->addDocumentPaymentTerm('Wird von Konto DE12500105170648489890 abgebucht', DateTime::createFromFormat("Ymd", "20250131"), 'MANDATE-2024/000001');
        $documentBuilder->setDocumentSeller("Lieferant GmbH", "549910");
        $documentBuilder->addDocumentSellerGlobalId("4000001123452", "0088");
        $documentBuilder->addDocumentSellerTaxNumber("201/113/40209");
        $documentBuilder->addDocumentSellerVATRegistrationNumber("DE123456789");
        $documentBuilder->setDocumentSellerAddress("Lieferantenstraße 20", "", "", "80333", "München", ZugferdCountryCodes::GERMANY);
        $documentBuilder->setDocumentSellerContact("H. Müller", "Verkauf", "+49-111-2222222", "+49-111-3333333", "hm@lieferant.de");
        $documentBuilder->setDocumentSellerCommunication(ZugferdElectronicAddressScheme::UNECE3155_EM, 'sales@lieferant.de');
        $documentBuilder->setDocumentBuyer("Kunden AG Mitte", "GE2020211");
        $documentBuilder->setDocumentBuyerAddress("Kundenstraße 15", "", "", "69876", "Frankfurt", ZugferdCountryCodes::GERMANY);
        $documentBuilder->setDocumentBuyerContact("H. Meier", "Einkauf", "+49-333-4444444", "+49-333-5555555", "hm@kunde.de");
        $documentBuilder->setDocumentBuyerCommunication(ZugferdElectronicAddressScheme::UNECE3155_EM, 'purchase@kunde.de');
        $documentBuilder->setDocumentPayee('Kunden AG Zahlungsdienstleistung');
        $documentBuilder->setDocumentBuyerOrderReferencedDocument("PO-2024-0003324");
        $documentBuilder->setDocumentSellerOrderReferencedDocument('SO-2024-000993337');
        $documentBuilder->setDocumentShipTo("Kunden AG Ost");
        $documentBuilder->setDocumentShipToAddress("Lieferstraße 1", "", "", "04109", "Leipzig", ZugferdCountryCodes::GERMANY);
        $documentBuilder->setDocumentSupplyChainEvent(DateTime::createFromFormat("Ymd", "20250115"));
        $documentBuilder->addNewPosition("1");
        $documentBuilder->setDocumentPositionProductDetails("Trennblätter A4", "50er Pack", "TB100A4");
        $documentBuilder->setDocumentPositionNetPrice(9.9000);
        $documentBuilder->setDocumentPositionQuantity(20, ZugferdUnitCodes::REC20_PIECE);
        $documentBuilder->addDocumentPositionTax(ZugferdVatCategoryCodes::STAN_RATE, ZugferdVatTypeCodes::VALUE_ADDED_TAX, 19);
        $documentBuilder->setDocumentPositionLineSummation(198.0);
        $documentBuilder->addNewPosition("2");
        $documentBuilder->setDocumentPositionProductDetails("Joghurt Banane", "B-Ware", "ARNR2");
        $documentBuilder->setDocumentPositionNetPrice(5.5000);
        $documentBuilder->setDocumentPositionQuantity(50, ZugferdUnitCodes::REC20_PIECE);
        $documentBuilder->addDocumentPositionTax(ZugferdVatCategoryCodes::STAN_RATE, ZugferdVatTypeCodes::VALUE_ADDED_TAX, 7);
        $documentBuilder->setDocumentPositionLineSummation(275.0);
        $documentBuilder->addNewPosition("3");
        $documentBuilder->setDocumentPositionProductDetails("Joghurt Erdbeer", "", "ARNR3");
        $documentBuilder->setDocumentPositionNetPrice(4.0000);
        $documentBuilder->setDocumentPositionQuantity(100, ZugferdUnitCodes::REC20_PIECE);
        $documentBuilder->addDocumentPositionTax(ZugferdVatCategoryCodes::STAN_RATE, ZugferdVatTypeCodes::VALUE_ADDED_TAX, 7);
        $documentBuilder->setDocumentPositionLineSummation(400.0);
        $documentBuilder->addDocumentTax(ZugferdVatCategoryCodes::STAN_RATE, ZugferdVatTypeCodes::VALUE_ADDED_TAX, 198.0, 37.62, 19.0);
        $documentBuilder->addDocumentTax(ZugferdVatCategoryCodes::STAN_RATE, ZugferdVatTypeCodes::VALUE_ADDED_TAX, 675.0, 47.25, 7.0);
        $documentBuilder->setDocumentSummation(957.87, 957.87, 873.00, 0.0, 0.0, 873.00, 84.87);

        // Next let's do the ZugferddocumentPdfBuilder it's job - let's attach the XML to the PDF. The attachment filename will be factur-x.xml
        // since whe choosed the profile EN16931 in the ZugferdDocumentBuilder (see above)
        // In the following there are multiple methods how you can build a conform PDF from an existing print layout

        // First method: Merge the generated XML from ZugferdDocumentBuilder with an existing print layout file to a new PDF file

        $zugferdDocumentPdfBuilder = ZugferdDocumentPdfBuilder::fromPdfFile($documentBuilder, $existingPdfFilename);
        $zugferdDocumentPdfBuilder->generateDocument();
        $zugferdDocumentPdfBuilder->saveDocument($newPdfFilename);

        // Second method: Merge the generated XML from ZugferdDocumentBuilder with an stream (string) which contains the PDF to a new PDF file
        // Note: We simulate the PDF stream (string) by calling file_get_contents.

        $pdfContent = file_get_contents($existingPdfFilename);

        $zugferdDocumentPdfBuilder = ZugferdDocumentPdfBuilder::fromPdfString($documentBuilder, $pdfContent);
        $zugferdDocumentPdfBuilder->generateDocument();
        $zugferdDocumentPdfBuilder->saveDocument($newPdfFilename);

        // There is not only the saveDocument method of the ZugferdDocumentPdfBuilder. It is also possible to receive the merged
        // content (PDF with embedded XML) as a stream (string)

        $mergedPdfContent = $zugferdDocumentPdfBuilder->downloadString();

        // If you would like to brand the merged PDF with the name of you own solution you can call
        // the method setAdditionalCreatorTool. Before calling this method the creator of the PDF is identified as 'Factur-X library 1.x.x by HorstOeko'.
        // After calling this method you get 'MyERPSolution 1.0 / Factur-X PHP library 1.x.x by HorstOeko' as the creator

        $zugferdDocumentPdfBuilder = ZugferdDocumentPdfBuilder::fromPdfString($documentBuilder, $pdfContent);
        $zugferdDocumentPdfBuilder->setAdditionalCreatorTool('MyERPSolution 1.0');
        $zugferdDocumentPdfBuilder->generateDocument();
        $zugferdDocumentPdfBuilder->saveDocument($newPdfFilename);

        // And last but not least, it is also possible to add additional attachments to the merged PDF. These can be any files that can help the invoice
        // recipient with processing. For example, a time sheet as an Excel file would be conceivable.
        // The method attachAdditionalFileByRealFile has 3 parameters:
        // - The file to attach which must exist and must be readable
        // - (Optional) A name to display in the attachments of the PDF
        // - (Optional) The type of the relationship of the attachment. Valid values are defined in the class ZugferdDocumentPdfBuilderAbstract. The constants are starting with AF_
        // If you omit the last 2 parameters the following will happen:
        // - The displayname is calculated from the filename you specified
        // - The type of the relationship of the attachment will be AF_RELATIONSHIP_SUPPLEMENT (Supplement)

        $zugferdDocumentPdfBuilder = ZugferdDocumentPdfBuilder::fromPdfString($documentBuilder, $pdfContent);
        $zugferdDocumentPdfBuilder->attachAdditionalFileByRealFile($AdditionalDocument, "Some display Name", ZugferdDocumentPdfBuilderAbstract::AF_RELATIONSHIP_SUPPLEMENT);
        $zugferdDocumentPdfBuilder->generateDocument();
        $zugferdDocumentPdfBuilder->saveDocument($newPdfFilename);

        // You can also add an attachment to the PDF as an stream (string). The conditions are the same as above for the attachAdditionalFileByRealFile method
        // The only difference to attachAdditionalFileByRealFile is that the attachAdditionalFileByContent method accepts 4 parameters, whereby here (as with attachAdditionalFileByRealFile)
        // the last two can be omitted. You only need to specify a file name under which the file is to be embedded
        // Note: We simulate the attachment stream (string) by calling file_get_contents.

        $attachmentContent = file_get_contents($AdditionalDocument);

        $zugferdDocumentPdfBuilder = ZugferdDocumentPdfBuilder::fromPdfString($documentBuilder, $pdfContent);
        $zugferdDocumentPdfBuilder->attachAdditionalFileByContent($attachmentContent, 'additionalDocument.csv', "Some other display Name", ZugferdDocumentPdfBuilderAbstract::AF_RELATIONSHIP_SUPPLEMENT);
        $zugferdDocumentPdfBuilder->generateDocument();
        $zugferdDocumentPdfBuilder->saveDocument($newPdfFilename);

        // Set values for metadata-fields
        // We can change some meta information such as the title, the subject, the author and the keywords.  This library essentially provides 4 methods for this.
        // These methods use so-called templates. These methods are:

        $zugferdDocumentPdfBuilder = ZugferdDocumentPdfBuilder::fromPdfFile($documentBuilder, $existingPdfFilename);
        $zugferdDocumentPdfBuilder->setAuthorTemplate('.....');
        $zugferdDocumentPdfBuilder->setTitleTemplate('.....');
        $zugferdDocumentPdfBuilder->setSubjectTemplate('.....');
        $zugferdDocumentPdfBuilder->setKeywordTemplate('.....');
        $zugferdDocumentPdfBuilder->generateDocument();
        $zugferdDocumentPdfBuilder->saveDocument($newPdfFilename);

        // The 4 methods just mentioned accept a free text that can accept the following placeholders:
        // - %1$s .... contains the invoice number (is extracted from the XML data)
        // - %2$s .... contains the type of XML document, such as ‘Invoice’ (is extracted from the XML data)
        // - %3$s .... contains the name of the seller (extracted from the XML data)
        // - %4$s .... contains the invoice date (extracted from the XML data)
        // The following example generates...
        // - the author:  .... Issued by seller with name Lieferant GmbH
        // - the title    .... Lieferant GmbH : Invoice R-2024/00001
        // - the subject  .... Invoice-Document, Issued by Lieferant GmbH
        // - the keywords .... R-2024/00001, Invoice, Lieferant GmbH, 2024-12-31

        $zugferdDocumentPdfBuilder = ZugferdDocumentPdfBuilder::fromPdfFile($documentBuilder, $existingPdfFilename);
        $zugferdDocumentPdfBuilder->setAuthorTemplate('Issued by seller with name %3$s');
        $zugferdDocumentPdfBuilder->setTitleTemplate('%3$s : %2$s %1$s');
        $zugferdDocumentPdfBuilder->setSubjectTemplate('%2$s-Document, Issued by %3$s');
        $zugferdDocumentPdfBuilder->setKeywordTemplate('%1$s, %2$s, %3$s, %4$s');
        $zugferdDocumentPdfBuilder->generateDocument();
        $zugferdDocumentPdfBuilder->saveDocument($newPdfFilename);

        // If the previously mentioned options for manipulating the meta information are not sufficient,
        // you can also use a callback function. The following 4 parameters are passed to the callback
        // function in the specified order:
        // - $which               .... one of "author", "title", "subject" and "keywords"
        // - $xmlContent          .... the content of the xml as a string
        // - $invoiceInformation  .... an array with some information about the invoice
        // - $default             .... The default value for the specified field (see $which

        $zugferdDocumentPdfBuilder = ZugferdDocumentPdfBuilder::fromPdfFile($documentBuilder, $existingPdfFilename);
        $zugferdDocumentPdfBuilder->setMetaInformationCallback(
            function ($which) {
                if ($which === 'title') {
                    return "DummyTitle";
                }

                if ($which === 'author') {
                    return "DummyAuthor";
                }

                if ($which === 'subject') {
                    return "DummySubject";
                }

                if ($which === 'keywords') {
                    return "DummyKeywords";
                }
            }
        );
        $zugferdDocumentPdfBuilder->generateDocument();
        $zugferdDocumentPdfBuilder->saveDocument($newPdfFilename);

        // To remove the callback you can call the setMetaInformationCallback
        // method with a null value

        $zugferdDocumentPdfBuilder = ZugferdDocumentPdfBuilder::fromPdfFile($documentBuilder, $existingPdfFilename);
        $zugferdDocumentPdfBuilder->setMetaInformationCallback(null);
        $zugferdDocumentPdfBuilder->generateDocument();
        $zugferdDocumentPdfBuilder->saveDocument($newPdfFilename);

        return $newPdfFilename;
    }


    /**
     * determines the delivery dates and the corresponding order numbers within two arrays
     *
     * @param Array   $customerOrderReferenceList  array to store the corresponding order ids as strings
     * @param Array   $deliveryDateList            array to store the corresponding delivery dates as string in format YYYY-MM-DD
     * @param Facture $object invoice              object
     */
    private function _determineDeliveryDatesAndCustomerOrderNumbers(&$customerOrderReferenceList, &$deliveryDateList, $object)
    {
        // TODO: move this function to class utils
        $object->fetchObjectLinked();
        // check for delivery notes and correponding real delivery dates
        if (isset($object->linkedObjectsIds['shipping']) && \is_array($object->linkedObjectsIds['shipping'])) {
            foreach ($object->linkedObjectsIds['shipping'] as $expeditionId) {
                $expedition = new \Expedition($this->db);
                $expeditionFetchResult = $expedition->fetch($expeditionId);
                if ($expeditionFetchResult > 0) {
                    if (!empty($expedition->origin) && $expedition->origin == "commande" && !empty($expedition->origin_id)) {
                        $commande = new \Commande($this->db);
                        $commandeFetchResult = $commande->fetch($expedition->origin_id);
                        if ($commandeFetchResult > 0 && !empty($commande->ref_client)) {
                            $customerOrderReferenceList[] = $commande->ref_client;
                        }
                    }
                    if (!empty($expedition->date_delivery)) {
                        $deliveryDateList[] = \date('Y-m-d', $expedition->date_delivery);
                    }
                }
            }
        }
        // if delivery notes are linked and take the real delivery date from there. if no delivery notes are available,
        // take delivery date from order.
        if (isset($object->linkedObjectsIds['commande']) && \is_array($object->linkedObjectsIds['commande'])) {
            foreach ($object->linkedObjectsIds['commande'] as $commandeId) {
                $commande = new \Commande($this->db);
                $commandeFetchResult = $commande->fetch($commandeId);
                if ($commandeFetchResult > 0) {
                    if (!empty($commande->ref_client)) {
                        $customerOrderReferenceList[] = $commande->ref_client;
                    }
                    $commande->fetchObjectLinked();
                    $found = 0;
                    if (!empty($commande->linkedObjectsIds) && !empty($commande->linkedObjectsIds['shipping']) && \count($commande->linkedObjectsIds['shipping']) > 0) {
                        foreach ($commande->linkedObjectsIds['shipping'] as $expeditionId) {
                            $expedition = new \Expedition($this->db);
                            $expeditionFetchResult = $expedition->fetch($expeditionId);
                            if ($expeditionFetchResult > 0) {
                                if (!empty($expedition->date_delivery)) {
                                    $found++;
                                    $deliveryDateList[] = \date('Y-m-d', $expedition->date_delivery);
                                }
                            }
                        }
                    }
                    if ($found == 0) {
                        if (!empty($commande->delivery_date)) {
                            $deliveryDateList[] = \date('Y-m-d', $commande->delivery_date);
                        }
                    }
                }
            }
        }
        $customerOrderReferenceList = \array_unique($customerOrderReferenceList);
        \sort($customerOrderReferenceList);
        $deliveryDateList = \array_unique($deliveryDateList);
        \rsort($deliveryDateList);
    }

    /** VMA calcul n°tva intracomm si absent
     * in France only
     *
     */
    private function _thirdpartyCalcTva_intra(Facture &$object)
    { // TODO: move this function to class utils
        if ($object->thirdparty->country_code == 'FR' && empty($object->thirdparty->tva_intra) && !empty($object->thirdparty->tva_assuj)) {
            $siren = trim($object->thirdparty->idprof1);
            if (empty($siren)) {
                $siren = (int) substr(str_replace(' ', '', $object->thirdparty->idprof2), 0, 9);
            }
            if (!empty($siren)) {
                // [FR + code clé  + numéro SIREN ]
                //Clé TVA = [12 + 3 × (SIREN modulo 97)] modulo 97
                $cle = (12 + 3 * $siren % 97) % 97;
                $object->thirdparty->tva_intra = 'FR' . $cle . $siren;
            }
        }
    }

    /**
     * map type of invoices dolibarr <-> facturx
     * @param $object the invoice object
     *
     * @return  string|null code of invoice type
     */
    private function _getTypeOfInvoice($object)
    {
        $map = [
            CommonInvoice::TYPE_STANDARD        => ZugferdInvoiceType::INVOICE,
            CommonInvoice::TYPE_REPLACEMENT     => ZugferdInvoiceType::CORRECTION,
            CommonInvoice::TYPE_CREDIT_NOTE     => ZugferdInvoiceType::CREDITNOTE,
            CommonInvoice::TYPE_DEPOSIT         => ZugferdInvoiceType::PREPAYMENTINVOICE,
        ];
        return $map[$object->type] ?? null;
    }

    /**
     * extract id prof : it depends on country ...
     *
     * @param   $thirdpart  dolibarr thirdpart
     *
     * @return  string return siret siren or locale prod if
     */
    private function idprof($thirdpart)
    {
        $retour = "";
        switch ($thirdpart->country_code) {
            case 'BE':
                $retour = $thirdpart->idprof1;
                break;
            case 'DE':
                if (!empty($thirdpart->idprof6)) {
                    $retour = $thirdpart->idprof6;
                    break;
                } elseif (!empty($thirdpart->idprof2) && !empty($thirdpart->idprof3)) {
                    $retour = $thirdpart->idprof2 . $thirdpart->idprof3;
                } else {
                    $retour = $thirdpart->idprof1;
                }
                break;
            //SIRET
            case 'FR':
                $retour = $thirdpart->idprof2;
                break;
            default:
                $retour = $thirdpart->idprof2;
        }
        return $this->_remove_spaces($retour);
    }

    /**
     * remove spaces from string for example french people add spaces into long numbers like
     * SIRET: 844 431 239 00020
     *
     * @param   string  $str  string to cleanup
     *
     * @return  string  cleaned up string
     */
    private function _remove_spaces($str)
    {
        return preg_replace('/\\s+/', '', $str);
    }

    /**
     * buyer id prof depends on country
     *
     * @return  string idprof
     */
    private function thirdpartyidprof($object)
    {
        return $this->idprof($object->thirdparty);
    }

    /**
     * extract mail from contact or thirdparty
     *
     * @param   $contact dolibarr contact
     * @param   $thirdpart  dolibarr thirdpart/societe
     *
     * @return  string email of buyer
     */
    private function extractBuyerMail($contact, $thirdpart)
    {
        dol_syslog("pdpconnectfr extractBuyerMail : contact=" . $contact->email . " | soc=" . $thirdpart->email);
        if (!empty($contact->email)) {
            return $contact->email;
        }
        return $thirdpart->email;
    }

    /**
     * return IEC_6523 code (https://docs.peppol.eu/poacc/billing/3.0/codelist/ICD/)
     *
     * TODO: add other countries, at least europeans countries ...
     *
     * @return string code
     */
    private function IEC_6523_code($country_code)
    {
        $retour = "";
        switch ($country_code) {
            case 'BE':
                $retour = "0008";
                break;
            case 'DE':
                $retour = "0000";
                break;
            case 'FR':
                $retour = "0009";
                break;
            default:
        }
        return $retour;
    }

}
